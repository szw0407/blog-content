# 数的表示和计算

## BCD码

BCD码是二进制编码的十进制表示，即用四位二进制数表示一个十进制数。

对于BCD码，最常见的是8421码，即每个十进制数用四位二进制数表示，如0用0000表示，1用0001表示，2用0010表示，3用0011表示，以此类推，这样123就表示为0001,0010,0011。

## 进制转换

对于一个十进制的数字，转换为二进制的计算方法：

- 整数部分，除2取余，直到商为0，然后把余数倒过来写。如：6，$6 \div 2=3\dots0$，$3 \div 2=1\dots 1$，$1 \div 2=0\dots 1$，所以6的二进制表示为110。即$6=1\times 2^2+1\times 2^1+0\times 2^0$。
- 小数部分，乘2取整，直到小数部分为0，然后把整数部分写出来。如：0.4，$0.4 \times 2=0.8$，$0.8 \times 2=1.6$，$0.6 \times 2=1.2$，$0.2 \times 2=0.4$，发现此时出现了循环小数，所以0.4的二进制表示为$0.\dot{0}11\dot{0}$。

## 原码

第一位是符号位，0表示正数，1表示负数，其余位表示数值。

对于小数，第一位表示符号，其余位表示小数部分。

几个举例(八位二进制数)：

- 对于8，二进制表示为0001000，原码表示为0,0001000。
- 对于-17，二进制表示为0001001，原码表示为1,0001001。
- 对于$\frac{1}{8}$，0.0010000，原码表示为0.0010000。
- 对于$-\frac{1}{8}$，1.0010000，原码表示为1.0010000。

注意到存在两个0，一个是正零，一个是负零。

## 反码

正数的反码和原码相同，负数的反码是原码除符号位外取反。

几个举例(八位二进制数)：

- 对于8，二进制表示为0001000，原码表示为0,0001000，反码表示为0,0001000。
- 对于-17，二进制表示为0001001，原码表示为1,0001001，反码表示为1,1110110。
- 对于$\frac{1}{8}$，0.0010000，原码表示为0,0010000，反码表示为0.0010000。
- 对于$-\frac{1}{8}$，1.0010000，原码表示为1.0010000，反码表示为1.1101111。

## 补码

正数的补码和原码相同，负数的补码是反码加1。

几个举例(八位二进制数)：

- 对于8，二进制表示为0001000，原码表示为0,0001000，反码表示为0,0001000，补码表示为0,0001000。
- 对于-17，二进制表示为0001001，原码表示为1,0001001，反码表示为1,1110110，补码表示为1,1110111。
- 对于$\frac{1}{8}$，0.0010000，原码表示为0,0010000，反码表示为0.0010000，补码表示为0.0010000。
- 对于$-\frac{1}{8}$，1.0010000，原码表示为1.0010000，反码表示为1.1101111，补码表示为1.1110000。

这里解决了负零的问题，而且负数因此开源多一个数。

## 移码

由于直接比较补码的大小比较困难，所以引入了移码，即将补码的符号位取反。其实是一个函数映射关系，把$x$映射到了$2^n+x$，全体负数被经历了这次加法后变成正的了。

几个举例(八位二进制数)：

- 对于8，补码表示为0,0001000，移码表示为1,0001000。
- 对于-17，补码表示为1,1110111，移码表示为0,1110111。
- 对于$\frac{1}{8}$，补码表示为0.0010000，移码表示为1.0010000。
- 对于$-\frac{1}{8}$，补码表示为1.1110000，移码表示为0.1110000。

## 小数的浮点表示

上文所述的都是定点表示的小数，即符号位、小数点、小数部分。

对于一个数值部分$n$位的原码表示的小数，其表示的范围：$-(1-2^{-n})$到$1-2^{-n}$。

为了表示更大范围的小数，引入了浮点表示，即用科学计数法表示小数，即$N=2^j\times S$，其中$S$是尾数，$j$是阶码，2是基数（或者表示为二进制的10）。

规格化，就是尾数的最高位为1，如$N=0.110101\times {10}^{100}$。

浮点数分为：阶符、阶码、数符、数码。



## 定点数的计算

### 移位

移位是定点数的计算中最基本的操作，即把一个数的二进制表示向左或向右移动若干位。

算术移位是带符号的移位，逻辑移位是不带符号的移位。

算术移位，对于正数，不论原码、补码、反码，都是补0。对于负数，原码补0，反码补1，补码左移补0右移补1。补码的算数右移相对于除以2并且向负无穷舍入；算数左移相对于乘以2，并且向0舍入。

### 加减法

对于补码的加减法，实际上就是直接算（减法转化为加相反数），然后符号位产生的进位自然丢掉。

由于上述计算会导致溢出，所以需要检查溢出。

- 参与加法操作的两个数符号相同，其结果的符号与原操作数的符号不同，即为溢出。
- 最高位数值位向符号位的进位与符号位产生的进位不同，即为溢出。

对于判断溢出，于是产生另一个方式，将符号位扩展为两位，若两个符号位不一致时表明溢出。不论是否产生溢出，高位符号位即真正的符号位。

### 乘法

乘法的本质就是一个竖式加法，即，一系列的相加、移位。

先考虑原码乘法，以下介绍的算法是原码一位乘。

原码的乘法，先把两个数字全部作为正数处理。两个数字相乘：举例：0.1101 * 0.1011

$$
\begin{array}{|r|l|c|}
\hline
\text{部分积A} & \text{乘数C} & \text{说明} \\
\hline
0.0000 & 1011 & \text{初始值0} \\
+0.1101 & & \text{乘数末尾是1，加上乘数} \\
\hline
=0.1101 & & \\\hline
\rightarrow 0.0110 & 1\ 101 & \text{向右移位} \\

+0.1101 & & \text{乘数末尾是1，加上乘数} \\
\hline
=1.0011 & 1 & \\\hline
\rightarrow 0.1001 & 11\ 10 & \text{向右移位} \\

+0.0000 & & \text{乘数末尾是0，不加} \\\hline
=0.1001 & 11 & \\\hline
\rightarrow 0.0100 & 111\ 1 & \text{向右移位} \\
+0.1101 & & \text{乘数末尾是1，加上乘数} \\
\hline
=1.0001 & & \\
\hline
\rightarrow 0.1000 & 1111 & \text{向右移位} \\
\hline
\end{array}
$$

所以，0.1101 * 0.1011 = 0.10001111。然后判断符号，因为两个数符号相同，所以结果是正数。

对于这个算法，有一个改进的地方，就是可以使用两位乘，判断乘数的后两位是00，01，10还是11，决定加什么数字，并且每次移位2位。不赘述。

然后考虑补码的乘法。这里只介绍Booth算法。